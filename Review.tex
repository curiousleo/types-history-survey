\RequirePackage[l2tabu, orthodox]{nag}
\documentclass[12pt,toc=bibliography,numbers=noendperiod,
               footnotes=multiple,twoside]{scrartcl}
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{microtype}
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[oldstylenums,largesmallcaps,easyscsl]{kpfonts}
\usepackage[LGR,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textalpha}
\usepackage[british]{babel}
\usepackage[table,hyperref,dvipsnames]{xcolor}
\usepackage{csquotes}
\usepackage{alltt}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage[all]{xy}
\usepackage{bussproofs}
\usepackage{paralist}
\usepackage{amssymb}
\usepackage[autocite=footnote,citestyle=authoryear-comp,bibstyle=authoryear,
            dashed=false,isbn=false,doi=false,backend=biber]{biblatex}
\usepackage[bookmarks,hidelinks]{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}

%%% Custom LaTeX preamble
% serif, non-bold headings:
\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}
\addtokomafont{pageheadfoot}{\itshape}
% section numbering up to subsection
\setcounter{secnumdepth}{2}

% hyperlinks
\urlstyle{same} % normal text font (alternatives: tt, rm, sf)
\hypersetup{%
  pdftitle={The Curry-Howard correspondence},
  pdfauthor={Leonhard Markert (lm510), Emmanuel College}
}
\title{The Brouwer-Heyting-Kolmogorov-Curry-Howard-Tait-Fey correspondence,\\\emph{or}: the formulae-as-types, propositions-as-sets interpretation}
\author{Leonhard Markert}

\addbibresource{Bibliography.bib}
% \pagestyle{headings}

\hyphenation{com-po-nent tran-si-tion-ing}

%%% Body
\begin{document}

\maketitle

\abstract{XXX}

\tableofcontents

\section{Introduction}

% In order to make automated reasoning possible, we need to represent our propositions and proofs in a way that computers can read and manipulate. Lambda calculi have been used to build such representations with great success. I will review a selection of influential publications on the correspondence between various flavours of the lambda calculus and the propositions and proofs they allow us to represent. I will focus on typed lambda calculi à la Church in this survey.

XXX Need to introduce notation here: what is a type, a sort, a type judgement, a context? Also natural deduction primer: entailment, tree structure, axioms and rules.

\section{Early work on types and the Curry-Howard correspondence}

XXX Blurb on Schönfinkel and Church in the 20s and 30s?

\subsection{Howard on the Curry-Howard correspondence}

William Howard coined the slogan \enquote{formulae as types} in a set of notes privately circulated in 1969. They appeared as an essay in a book dedicated to Haskell B. Curry on the occasion of his 80th birthday in 1980 \autocite{howard_formulae-as-types_1980}. By this point, the idea of a correspondence between types and propositions had become widely accepted and research into this suprising connection was well under way. Still, this essay is often cited as the publication that originated what became known as the Curry-Howard correspondence (or isomorphism\footnote{XXX explain why it's not an isomorphism}).

Howard starts by noting that the rule which introduces an implication on the right-hand side in the sequent calculus is similar to \(\lambda\)-abstraction, and \emph{modus ponens} (the elimination rule for implication on the right-hand side) resembles application in the \(\lambda\)-calculus.

This simple
% (positive implicational propositional)
logic is then extended to include negation as functions with the empty type as their codomain, conjunction as pairing, and disjunction as what would today be called sum types. These corresponding notions from logic and type theory are listed in \cref{tab:howard}. The second part of the essay is concerned with constructing a set-theoretic interpretation of Heyting arithmetic including existential and universal quantifiers.

\subsection{De Bruijn's Automath project}

In the same book that Howard published his notes in, Nicolaas de Bruijn describes his project \enquote{to develop a system of writing entire mathematical theories in such a precise fashion that verification of the correctness can be carried out by formal operations on the text}, with the express intention to have computers verify proofs \autocite{de_bruijn_survey_1980}. The implementation of his Automath system is first motivated by describing how automated proof checking would benefit working mathematicians.
% it would increase confidence in the results; it would help in understanding proofs by requiring explicit assumptions; and it would allow for proofs to be processed like any other object in computer memory---one could, for example, find out whether a certain axiom or rule was used in a proof.

Under the heading \enquote{use of typing for reasoning}, de Bruijn gives some intuition for what he calls the \enquote{idea of \emph{propositions as types}} as applied to implication: given propositions \(p\) and \(q\), a proof of the implication \(p \rightarrow q\) can be interpreted as a procedure by which a proof of \(q\) is generated for any \(p\) passed to it. Later sections of the report discuss the potential benefits of introducing a proposition sort (\enquote{expression of degree 1}), and the beginnings of what would nowadays be called tactics. Both ideas have been realised in Coq, for example.\footnote{\url{http://coq.inria.fr}}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Logic} & \textit{Types} \\
        \midrule
	implication & \(\lambda\)-abstraction \\
	modus ponens & function application \\
	falsity & functions into the empty type \\
	conjunction & pairs \\
	disjunction & sum types \\
        \bottomrule
    \end{tabular}
    \caption{The Curry-Howard correspondence according to Howard \parencite{howard_formulae-as-types_1980}.}
    \label{tab:howard}
\end{table}


\section{More powerful type systems emerge}

\subsection{Martin-Löf's intuitionistic type theory}

A set of notes from a lecture series given by Per Martin-Löf in 1980 is the canonical reference\footnote{%
Martin-Löf published several papers on type theory and logic, as did de Bruijn, Coquand, Huet and most other authors whose publications this literature survey discusses. It is clear from the amount of cross-referencing and citing in those papers that the leading researchers at the time were often in close contact, criticising each other's work, finding mistakes or opening up new perspectives---\emph{science} was being done.

This makes untangling the development of the subject \emph{a posteriori} difficult. Martin-Löf developed his type theory over the course of multiple publications spanning decades. \enquote{The} calculus of constructions does not exist; instead, it is a term used by Coquand and Huet to refer to a family of type theories and conceptual programming languages described in at least four papers.

In this survey, I usually cite and describe the latest of such a series of publications on a particular topic by a particular author or set of authors.}
%
for \emph{intuitionistic type theory} (often referred to as \enquote{Martin-Löf type theory}), on which most of the following work discussed in this survey is based \autocite{sambin_intuitionistic_1984}.

Before going into type theory proper, Martin-Löf carefully distinguishes \emph{propositions} from \emph{judgements}: propositions are generated from logical operations and held to be true; holding a proposition to be true is to make a judgement. So when \(A\) is a proposition, then \enquote{\(A\) is true} is a judgement. The premisses and conclusion of a logical inference are judgements. As an example, the rule

\begin{prooftree}
\AxiomC{\(A\)}
\UnaryInfC{\(A \vee B\)}
\end{prooftree}

implicitly assumes that \(A\) and \(B\) are propositions, and states that we can infer that \(A \vee B\) holds if \(A\) is true. A formal rule would have to make this explicit:

\begin{prooftree}
\AxiomC{\(A\) prop}
\AxiomC{\(B\) prop}
\AxiomC{\(A\) true}
\TrinaryInfC{\(A \vee B\) true}
\end{prooftree}

\emph{Types} are then introduced using the following four judgements:

\begin{enumerate}
\item \(A\) is a set/type (in the notes this is written as \(A\) set). Sets/types are defined by describing how their canonical elements (\emph{values} in modern \(\lambda\)-calculus terminology) are formed and what equality of elements means in this set/type.
\item \(A\) and \(B\) are equal sets/types (\(A = B\)). \(A\) and \(B\) are equal if \(a : A\) entails \(a : B\) and \(a = b : A\) entails \(a = b : B\) and vice versa.
\item \(a\) is an element of the set/type \(A\) (written \(a \in A\) in the notes; we also use \(a : A\) here). This means that \(a\) is a \enquote{method (or program), which, when executed, yields a canonical element of \(A\) as a result.}
\item \(a\) and \(b\) are equal elements of the set/type \(A\) (written \(a = b \in A\) or \(a = b : A\)). For this to hold, \(a\) and \(b\) must yield equal canonical elements of \(A\) when executed.
\end{enumerate}

A discussion of \emph{equality} in the context of type theory is included. It differentiates between definitional (intensional) equality and propositional (extensional) equality. \emph{Definitional equality} (written \(a \equiv b\)) is the \enquote{equivalence relation generated by abbreviatory definitions, changes of bound variables and the principle of substituting equals for equals.} It is decidable on a meta-level, but \(a \equiv b\) is \emph{not} a proposition within the theory.

\emph{Propositional equality}, on the other hand, resides \emph{within} the theory. \(I(A, a, b)\) is a proposition asserting that \(a\) and \(b\) are equal elements of \(A\).

The remainder of the text contains a systematic account of the correspondence between ways of constructing types on the one hand and logical connectives and quantifiers on the other.\footnote{In the notes, set notation and nomenclature is used for types. I have tried to modernise the notation here for consistency.} Each type-forming symbol (see \cref{tab:martin-loef}) is defined by giving four rules:

\begin{description}
\item[Formation rules] state that this symbol forms a new type from existing types.
\item[Introduction rules] define the meaning of the symbol by giving its \emph{canonical elements}.
\item[Elimination rules] say how functions can be defined on this symbol's types.
\item[Equality rules] \enquote{relate the introduction and elimination rules by showing how a function defined by means of the elimination rule operates on the canonical elements of the [type] which are generated by the introduction rules}.
\end{description}

Considering these from the perspective of logic, formation rules are used to form propositions, introduction and elimination rules allow for Gentzen-style natural deduction, and equality rules correspond to reduction rules---in the parlance of \(\lambda\)-calculus, they would be called \(\beta\)- and \(\eta\)-reduction.

\begin{table}[h]
    \centering
    \begin{tabular}{l l l l}
        \toprule
        \textit{Logic} & & \textit{Types} & \\
        \midrule
	universal quantif'n & \((\forall x \in A)\;B(x)\)
		& generalised product & \((\Pi x : A)\;B(x)\) \\
	implication & \(A \rightarrow B\)
		& ---with \(B\) indep't of \(x\) & \((\Pi x : A)\;B\) \\
	existential quantif'n & \((\exists x \in A)\;B(x)\)
		& disjoint union & \((\Sigma x : A)\;B(x)\) \\
	conjunction & \(A \wedge B\)
		& ---with \(B\) indep't of \(x\) & \((\Sigma x : A)\;B\) \\
	disjunction & \(A \vee B\)
		& sum & \(A + B\) \\
	identity & \(A = B\)
		& equality & \(I(A, a, b)\) \\
	
        \bottomrule
    \end{tabular}
    \caption{Symbols defined in Martin-Löf's intuitionistic type theory \parencite{sambin_intuitionistic_1984}.}
    \label{tab:martin-loef}
\end{table}

\subsection{Coquand and Huet's calculus of constructions}

Coquand and Huet's \emph{calculus of constructions} blends together the theoretical work by Martin-Löf and Girard with the more concrete proposals of de Bruijn \autocite{coquand_calculus_1988}. They first describe the metatheory of the calculus and then provide suggestions concerning how such a calculus could be implemented in a user-friendly way.

In the calculus of constructions, \(*\) represents the universe of all types, that is, the type of all types \emph{and} the type of all propositions. \(*\) is not of type \(*\) to avoid Girard's paradox.\footnote{A judgement like \(* : *\) in a type theory makes it possible to prove any proposition, or equivalently, implies that every type (even \(\bot\)) is inhabited. An early version of Martin-Löf's type theory was shown to suffer from this problem, usually referred to as \emph{Girard's paradox}, and the publication that is usually cited in this context is his doctoral thesis, \textcite{girard_interpretation_1972} (written in French). Thierry Coquand wrote a very readable introduction to the issue for the Stanford Encyclopedia of Philosophy, relating it, amongst others, to Russel's paradox \autocite{coquand_type_2014}. Coq and Agda avoid Girard's paradox via an infinite hierarchy of types---an approach that closely resembles Grothendieck's solution to similar issues in set theory by introducing what are now called \emph{Grothendieck universes} \autocite{artin_orie_1972}.} This differs from the Automath languages, where propositions are of type \texttt{prop}, types are of type \texttt{type} and both \texttt{type} and \texttt{prop} have type \(\tau\).

\emph{Contexts} (Martin-Löf's \enquote{hypothetical judgements}) are defined as \enquote{[t]erms formed solely of products over \(*\) [\dots] They are the types of logical propositions and proposition schemas}. The paper refers to other terms as \emph{objects}.

The core calculus, which resembles Martin-Löf's and also draws inspiration from Girard, is then extended by conversion rules of the form \(\Gamma \vdash M \cong N\) meaning that the terms \(M\) and \(N\) denote the same object (where \(\Gamma\) is a context). It formalises \(\beta\)-conversion at the type level.

An interpretation (or semantics) of terms is given: contexts map to products, for example, and variables to projections picking out the appropriate type from the context. It is then shown that the calculus of constructions is \emph{consistent} in the sense that \enquote{there exists a proposition which is not inhabited.} This non-inhabited proposition or empty type is usually referred to as \(\bot\) (\enquote{bottom}). What this theorem means is that there is no term in the calculus of constructions of type \(\bot\), or alternatively, \emph{false} cannot be derived.

The section concerned with making the calculus of constructions user-friendly makes three concrete proposals: allowing the local definitions (constants) via a \texttt{let} construct; making type arguments which can be inferred from other arguments implicit; and providing a way to extend the syntax of the language. As an example for the last suggestion, a composition operator is introduced as a syntax extension.


\subsection{Luo's extended calculus of constructions}

The \emph{extended calculus of constructions} (ECC), first presented by Zhaohui Luo in 1989\autocite{luo_ecc_1989}, expanded upon in his PhD thesis\autocite{luo_extended_1990} and used as the basis for his unified type theory in \citetitle{luo_computation_1994}\autocite{luo_computation_1994}, adds \(\Sigma\)-types to the calculus of constructions to provide an abstraction mechanism.

After listing the inference rules of ECC, demonstrating its proof-theoretic properties and giving an intuitionistic set-theoretic semantics, Luo discusses the pragmatics of ECC: expressing and structuring mathematical theories. The example given in \textcite{luo_ecc_1989} is a theory of rings. A simpler example, which we will use here, is given in \textcite{luo_extended_1990}: semigroups (defined as a carrier set closed under an associative binary operation \(\_\cdot\_\)).

A straightforward way of formalising semigroups would be to define a context \(\Gamma_{sg} \triangleq X : \textrm{Type}_0, \_\cdot\_ : X \rightarrow X \rightarrow X, p : P_\textrm{assoc}\), where \(P_\textrm{assoc} \triangleq \Pi x,y,z:X.(x \cdot (y \cdot z) = (x \cdot y) \cdot z)\) represents associativity of the binary operation. Luo observes that expressing theories in this way quickly becomes unwieldy.

Instead, he proposes to use \(\Sigma\)-types to represent theories in an abstract manner. An \emph{abstract} theory of semigroups would consists of two parts:\footnote{This presentation of semigroup theory is taken directly from \textcite[100]{luo_extended_1990}.}

\begin{itemize}
\item an (abstract) \emph{signature presentation} \[\textrm{Sig}_{sg} \triangleq \Sigma X : \textrm{Type}_0. X \rightarrow X \rightarrow X\]
\item an (abstract) \emph{axiom} \(\textrm{Ax}_{sg}\) being a predicate over \(\textrm{Sig}_{sg}\) which, when given any structure \(s\) of type \(\textrm{Sig}_{sg}\), returns its associativity axiom.
\end{itemize}

The signature presentation and the axiom can be packaged together as \[\textrm{Mod}_{sg} \triangleq \Sigma s : \textrm{Sig}_{sg}. \textrm{Ax}_{sg}(s)\] which then represents a complete abstract theory of semigroups. In order to postulate an arbitrary semigroup, one just assumes a context \(\Gamma'_{sg} \triangleq sg : \textrm{Mod}_{sg}\).

Theorems over any semigroup (abstract theorems) then constitute a predicate \(\textrm{Thm}_{sg}\) over \(\textrm{Sig}_{sg}\) with the general form \[\textrm{Thm}_{sg} \triangleq \lambda s : \textrm{Sig}_{sg}. P_1 \wedge P_2 \wedge \dots \wedge P_n\] where \(P_1\) to \(P_n\) are the types corresponding to the theorems that have been proved. Given any concrete semigroup structure, \(\textrm{Prf}_{sg}\), a term of type \(\Pi sg : \textrm{Mod}_{sg}. \textrm{Thm}_{sg}(\pi_1(sg))\), results in the proofs specialised to that particular semigroup structure.

\subsection{Pfenning and Paulin-Mohring's calculus of inductive constructions}

\textcite{pfenning_inductively_1990} extends the calculus of constructions with inductively defined types---an extension which, interestingly, does not augment its computational capabilities, it only makes the proof language more powerful.

A short introduction to the calculus of constructions is given before defining the syntax for inductively defined types. Many examples follow, including a definition of natural numbers (see \cref{fig:nat-inductive-type}) and lists (see \cref{fig:list-inductive-type}).

\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.3\linewidth}
\begin{alltt}
\textbf{indtype} nat : * with
    \textbf{zero} : nat
    \textbf{succ} : nat \(\rightarrow\) nat
end
\end{alltt}
\end{subfigure}
\caption{Natural numbers in the calculus of inductive constructions.}
\label{fig:nat-inductive-type}
\end{figure}

\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.4\linewidth}
\begin{alltt}
\textbf{indtype} list : * \(\rightarrow\) * with
    \textbf{nil}  : [A : *] list A
    \textbf{cons} : [A : *] A \(\rightarrow\) list A \(\rightarrow\) list A
end
\end{alltt}
\end{subfigure}
\caption{Lists in the calculus of inductive constructions.}
\label{fig:list-inductive-type}
\end{figure}

The definition of an inductive type \(\alpha\) can be thought of as a rule for \(\alpha\)-introduction. The corresponding \(\alpha\)-elimination is done via \emph{primitive recursion over \(\alpha\)}, or what is usually called pattern matching in functional programming languages. The schema for lists, for example, is given by

\begin{align*}
f A (\texttt{nil}\;A) &= h'_1\;A \\
f A (\texttt{cons}\;A\;x\;l) &= h'_2\;A\;x\;(\texttt{pair}\;l\;(f\;A\;l))
\end{align*}


\section{Uniform formalisations of the Curry-Howard correspondence}

\subsection{Barendregt's \(\lambda\)-cube and the logic cube}

In the last section of his 191-page chapter \citetitle{barendregt_lambda_1992} in the Handbook of Logic in Computer Science, vol. 2, Henk Barendregt sets out to uniformly describe eight type systems, with the calculus of constructions the most powerful of all. The result is the \(\lambda\)-cube shown in \cref{fig:lambda-cube}, where edges (\(X \longrightarrow Y\)) represent the inclusion relation \(X \subseteq Y\). The type systems in the \(\lambda\)-cube are labelled using Barendregt's own naming scheme. Most of them had already appeared in previous work---see \cref{tab:lambda-cube-type-systems}.

\begin{figure}
\begin{equation*}
\xymatrix@R46pt@C40pt{%
&\lambda\omega\ar@{->}[rr]&&\lambda\textrm{C} \\
\lambda\textrm{2}\ar@{->}[rr]\ar@{->}[ur]&&\lambda\textrm{P2}\ar@{->}[ur] \\
&\lambda\underline{\omega}\ar@{->}[uu]|!{"2,1";"2,3"}\hole\ar@{->}[rr]|!{"4,3";"2,3"}\hole&&\lambda\textrm{P}\underline{\omega}\ar@{->}[uu] \\
\lambda^{\rightarrow}\ar@{->}[uu]\ar@{->}[rr]\ar@{->}[ur]&&\lambda\textrm{P}\ar@{->}[uu]\ar@{->}[ur]
}
\end{equation*}
\caption{The \(\lambda\)-cube.}
\label{fig:lambda-cube}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Label} & \textit{Also known as} \\
        \midrule
        \(\lambda^{\rightarrow}\) & Simply typed \(\lambda\)-calculus (Church) \\
        \(\lambda\textrm{2}\) & Polymorphic \(\lambda\)-calculus or \emph{Système F} (Girard) \\
        \(\lambda\omega\) & \emph{Système F\(\omega\)} (Girard) \\
        \(\lambda\textrm{P}\) & \emph{LF} (Harper) and Automath languages (de Bruijn) \\
        \(\lambda\textrm{P2}\) & Studied by Longo and Moggi \\
        \(\lambda\textrm{C} = \lambda\textrm{P}\omega\) & Calculus of constructions (Coquand and Huet) \\
        \(\lambda\underline{\omega}\) (\enquote{weak} \(\lambda\omega\)) & Related to a system studied by de Lavalette \\
        \(\lambda\textrm{P}\underline{\omega}\) (\enquote{weak} \(\lambda\textrm{P}\omega\)) & --- \\
        \bottomrule
    \end{tabular}
    \caption{Other names for the type systems in the \(\lambda\)-cube. Summary based on \textcite[193]{barendregt_lambda_1992}.}
    \label{tab:lambda-cube-type-systems}
\end{table}

A key insight in this uniform description of type systems is the mutual dependence of types and terms: there are

\begin{itemize}
\item terms depending on terms;
\item terms depending on types;
\item types depending on types;
\item types depending on terms (dependent types).
\end{itemize}

Barendregt starts by defining the systems \(\lambda^{\rightarrow}\), \(\lambda\textrm{2}\), \(\lambda\underline{\omega}\) and \(\lambda\textrm{P}\) in the usual way. Then a general treatment of all systems in the \(\lambda\)-cube is presented. We summarise it here:

\begin{enumerate}
\item The systems of the \(\lambda\)-cube have the following abstract syntax: \[\mathcal{T} = V \;|\; C \;|\; \mathcal{T}\mathcal{T} \;|\; \lambda V\!\!:\!\mathcal{T}\!.\mathcal{T} \;|\; \Pi V\!\!:\!\mathcal{T}\!.\mathcal{T}\] where \(V\) and \(C\) stand for variables and constants, respectively. Note that no distinction between type- and term-variables is made.
\item \(\beta\)-reduction is defined by the contraction rule \[(\lambda x:A.B)C \rightarrow B[x \coloneqq C]\]
\item Contexts are finite ordered sequences of declarations \(x:A\), where \(A \in \mathcal{T}\) and \(x\) a variable. The empty context is written \(<>\).
\item The typing judgements (see \cref{fig:lambda-cube-typing}) axiomatise the notion \[\Gamma \vdash A:B\] stating that \(A:B\) can be derived from context \(\Gamma\). Note that \(A \rightarrow B \equiv \Pi x:A.B\) if \(x\) does not appear free in either \(A\) or \(B\).

There are general rules which apply to all systems and the specific rules called \((s_1, s_2)\) rules. In the following, \(s\), \(s_1\) and \(s_2\) range over the set of \emph{sorts}, \(\mathcal{S} \triangleq \{*, \square\}\).
\item The systems of the \(\lambda\)-cube are then defined by instantiating the \((s_1, s_2)\) rules with a subset of \(\{(*,*), (\square, *), (*,\square), (\square, \square)\}\) as in \cref{tab:lambda-cube-s-rules}.

\begin{table}[h]
    \centering
    \begin{tabular}{l l l l l}
        \toprule
        \textit{System} & \multicolumn{4}{l}{\textit{Specific rules}}  \\
        \midrule
        \(\lambda^{\rightarrow}\) & \((*,*)\) & & & \\
        \(\lambda\textrm{2}\) & \((*,*)\) & \((\square, *)\) & & \\
        \(\lambda\textrm{P}\) & \((*,*)\) & & \((*,\square)\) & \\

        \(\lambda\textrm{P2}\) & \((*,*)\) & \((\square, *)\) & \((*,\square)\) & \\

        \(\lambda\underline{\omega}\) & \((*,*)\) & & & \((\square, \square)\) \\

        \(\lambda\omega\) & \((*,*)\) & \((\square, *)\) & & \((\square, \square)\) \\

        \(\lambda\textrm{P}\underline{\omega}\) & \((*,*)\) & & \((*,\square)\) & \((\square, \square)\) \\

        \(\lambda\textrm{P}\omega = \lambda\textrm{C}\) & \((*,*)\) & \((\square, *)\) & \((*,\square)\) & \((\square, \square)\) \\

        \bottomrule
    \end{tabular}
    \caption{Specific rules for the systems of the \(\lambda\)-cube. Table taken from \textcite[205]{barendregt_lambda_1992}.}
    \label{tab:lambda-cube-s-rules}
\end{table}
\end{enumerate}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(<>\;\vdash * : \square\)}
        \end{prooftree}
    \end{minipage}
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A : s\)}
            \LeftLabel{(start)}
            \RightLabel{if \(x \notin \Gamma\)}
            \UnaryInfC{\(\Gamma,x:A \vdash x:A\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash C:s\)}
            \LeftLabel{(weakening)}
            \RightLabel{if \(x \notin \Gamma\)}
            \BinaryInfC{\(\Gamma,x:C \vdash A:B\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash F:(\Pi x:A.B)\)}
            \AxiomC{\(\Gamma \vdash a:A\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash F a:B[x \coloneqq a]\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,x:A \vdash b:B\)}
            \AxiomC{\(\Gamma \vdash (\Pi x:A.B):s\)}
            \LeftLabel{(abstraction)}
            \BinaryInfC{\(\Gamma \vdash (\lambda x:A.b):(\Pi x:A.B)\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash B':s\)}
            \AxiomC{\(B =_\beta B'\)}
            \LeftLabel{(conversion)}
            \TrinaryInfC{\(\Gamma \vdash A:B'\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s_1\)}
            \AxiomC{\(\Gamma,x:A \vdash B:s_2\)}
            \LeftLabel{(\((s_1, s_2)\) rule)}
            \BinaryInfC{\(\Gamma \vdash (\Pi x:A.B):s_2\)}
        \end{prooftree}
    \end{minipage}
    \caption{Axiom and typing judgements of the \(\lambda\)-cube.}
    \label{fig:lambda-cube-typing}
\end{figure}

% \((\square, *)\) is impredicative

The description of the \(\lambda\)-cube is followed by many examples of what kinds of expressions are admissible in its type systems. Next, the \emph{logic cube} is introduced (\cref{fig:l-cube}): it contains eight systems of intuitionistic logic, each corresponding to the type system at the same corner in the \(\lambda\)-cube. Again, the naming scheme is non-standard so a short description of each logic is provided (\cref{tab:l-cube-names}).

\enquote{Weakly higher-order logics} have variables for higher-order propositions or predicates but no quantification over them. Again, the edges of the cube represent inclusion.

The correspondence between the two cubes is a generalised version of the Curry-Howard interpretation: each formula \(A\) in logic \(L_i\) on the logic cube can be interpreted as a type \(\llbracket A \rrbracket\) in the corresponding system \(\lambda_i\) on the \(\lambda\)-cube. If \(A\) is provable in \(L_i\) then \(\llbracket A \rrbracket\) is inhabited in \(\lambda_i\) (soundness).\footnote{Barendregt quotes Geuvers' Master thesis from 1988 for this result. Unfortunately I was unable to track it down.} Completeness (inhabitation of \(\llbracket A \rrbracket\) implies \(A\) is provable) holds for propositional logics but not in general for predicate logics. For example, completeness for PRED\(\omega\) (higher-order logic) with respect to \(\lambda\)C (calculus of constructions) fails.

\begin{figure}
\begin{equation*}
\xymatrix@R46pt@C16pt{%
&\textrm{PROP}\omega\ar@{->}[rr]&&\textrm{PRED}\omega \\
\textrm{PROP2}\ar@{->}[rr]\ar@{->}[ur]&&\textrm{PRED2}\ar@{->}[ur] \\
&\textrm{PROP}\underline{\omega}\ar@{->}[uu]|!{"2,1";"2,3"}\hole\ar@{->}[rr]|!{"4,3";"2,3"}\hole&&\textrm{PRED}\underline{\omega}\ar@{->}[uu] \\
\textrm{PROP}\ar@{->}[uu]\ar@{->}[rr]\ar@{->}[ur]&&\textrm{PRED}\ar@{->}[uu]\ar@{->}[ur]
}
\end{equation*}
\caption{The logic cube.}
\label{fig:l-cube}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Label} & \textit{Description} \\
        \midrule
        PROP & Propositional logic \\
        PROP2 & Second-order propositional logic \\
        PROP\(\underline{\omega}\) & Weakly higher-order propositional logic \\
        PROP\(\omega\) & Higher-order propositional logic \\
        PRED & Predicate logic \\
        PRED2 & Second-order predicate logic \\
        PRED\(\underline{\omega}\) & Weakly higher-order predicate logic \\
        PRED\(\omega\) & Higher-order predicate logic \\
        \bottomrule
    \end{tabular}
    \caption{The logics in the logic cube. Taken from \textcite[248]{barendregt_lambda_1992}.}
    \label{tab:l-cube-names}
\end{table}


\subsection{Pure type systems}

Berardi and Terlouw independently generalised the framework of the \(\lambda\)-cube to what \textcite{barendregt_lambda_1992} calls \emph{pure type systems}. It accomodates all the systems in the \(\lambda\)-cube and allows subtle differences between many more type systems to be described in a succinct manner. We summarise the definition here, following \textcite[213f.]{barendregt_lambda_1992}:

\begin{enumerate}
\item Pure type systems have the same abstract syntax as those in the \(\lambda\)-cube: \[\mathcal{T} = V \;|\; C \;|\; \mathcal{T}\mathcal{T} \;|\; \lambda V\!\!:\!\mathcal{T}\!.\mathcal{T} \;|\; \Pi V\!\!:\!\mathcal{T}\!.\mathcal{T}\]
\item The \emph{specification} of a pure type system is given by \[S = (\mathcal{S}, \mathcal{A}, \mathcal{R})\] where \(S \subseteq C\) denotes the \emph{sorts}, \(\mathcal{A}\) is a set of \emph{axioms} of the form \(c:s\) with \(c \in \mathcal{C}\) and \(s \in \mathcal{S}\), and \(\mathcal{R}\) is a set of rules of the form \((s_1, s_2, s_3)\) with \(s_1, s_2, s_3 \in \mathcal{S}\).
\item We divide the set \(V\) of variables into disjoint subsets \(V_s\) for each sort \(s \in \mathcal{S}\) and denote by \(\prescript{s}{}x, \prescript{s}{}y, \prescript{s}{}z, \dots\) the members of \(V_s\).
\item Contexts are defined as for the \(\lambda\)-cube. The axiom and typing judgements are listed in \cref{fig:pts-typing}, where \(x\) ranges over variables and \(s\) ranges of \(\mathcal{S}\), the set of sorts.
\end{enumerate}

A list of examples of pure type systems follows. Two type systems also present in the \(\lambda\)-cube, \(\lambda^{\rightarrow}\) and \(\lambda\textrm{C}\), are determined by

\begin{align*}
\lambda^{\rightarrow} &\triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square\} \\
        \mathcal{A} &= \{*:\square\} \\
        \mathcal{R} &= \{(*,*),(\square,*)\}
    \end{cases} &
\lambda\textrm{C} &\triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square\} \\
        \mathcal{A} &= \{*:\square\} \\
        \mathcal{R} &= \{(*,*),(\square,*),(*,\square),(\square,\square)\}
    \end{cases}
\end{align*}

An example for a system that cannot be represented in the \(\lambda\)-cube is \(\lambda\textrm{U}\), a non-circular system that has been shown to be inconsistent by Girard:

\begin{align*}
\lambda\textrm{U} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square,\Delta\} \\
        \mathcal{A} &= \{*:\square,\square:\Delta\} \\
        \mathcal{R} &= \{(*,*),(\square,*),(\square,\square),(\Delta,\square),(\Delta,*)\}
    \end{cases}
\end{align*}

Many lemmas and proofs follow, leading up the the proof of strong normalisation for all systems in the \(\lambda\)-cube.

Pure type system specification are general enough to also allow for logics in the logic cube to be considered as such. One example is propositional logic (PROP), which corresponds to \(\lambda^{\rightarrow}\) in the \(\lambda\)-cube. The specification looks remarkably similar to that of the type system: the latter can be obtained from the former by removing the superscripts.

\begin{align*}
\lambda\textrm{PROP} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*^p,\square^p\} \\
        \mathcal{A} &= \{*^p:\square^p\} \\
        \mathcal{R} &= \{(*^p,*^p)\}
    \end{cases}
\end{align*}

A more complex example is predicate logic (PRED), determined by the following specification:

\begin{align*}
\lambda\textrm{PRED} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*^s,*^p,*^f,\square^s,\square^p\} \\
        \mathcal{A} &= \{*^s:\square^s,*^p:\square^p\} \\
        \mathcal{R} &= \{(*^p,*^p),(*^s,*^p),(*^s,\square^p),(*^s,*^s,*^f),(*^s,*^f,*^f)\}
    \end{cases}
\end{align*}

The sorts of this pure type system are \(*^s\) for sets, \(*^p\) for propositions and~\(*^f\) for first-order functions between the sets in \(*^s\); \(\square^s\) contains \(*^s\) and \(\square^p\) contains \(*^p\). Note that there is no \(\square^f\) since PRED does not allow variables ranging over functions spaces. Its rules can be interpreted as follows:\footnote{For examples of how the \(\lambda\textrm{PRED}\) rules can be used, see \textcite[255]{barendregt_lambda_1992}}

\begin{description}
\item[\((*^p,*^p)\)] allows the formation of implication.
\item[\((*^s,*^p)\)] allows quantification over sets.
\item[\((*^s,\square^p)\)] allows the formation of first-order predicates.
\item[\((*^s,*^s,*^f)\)] allows the formation of a function space between the basic sets.
\item[\((*^s,*^f,*^f)\)] allows the formation of curried functions of several arguments in the basic sets.
\end{description}

\begin{figure}
    \centering
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \RightLabel{if \((c:s) \in \mathcal{A}\)}
            \UnaryInfC{\(<>\;\vdash c:s\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s\)}
            \LeftLabel{(start)}
            \RightLabel{if \(x \equiv \prescript{s}{}x \notin \Gamma\)}
            \UnaryInfC{\(\Gamma,x:A \vdash x:A\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash C:s\)}
            \LeftLabel{(weakening)}
            \RightLabel{if \(x \equiv \prescript{s}{}x \notin \Gamma\)}
            \BinaryInfC{\(\Gamma,x:C \vdash A:B\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash F:(\Pi x:A.B)\)}
            \AxiomC{\(\Gamma \vdash a:A\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash F a:B[x \coloneqq a]\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma,x:A \vdash b:B\)}
            \AxiomC{\(\Gamma \vdash (\Pi x:A.B):s\)}
            \LeftLabel{(abstraction)}
            \BinaryInfC{\(\Gamma \vdash (\lambda x:A.b):(\Pi x:A.B)\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash B':s\)}
            \AxiomC{\(B =_\beta B'\)}
            \LeftLabel{(conversion)}
            \TrinaryInfC{\(\Gamma \vdash A:B'\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s_1\)}
            \AxiomC{\(\Gamma,x:A \vdash B:s_2\)}
            \LeftLabel{(product)}
            \RightLabel{if \((s_1, s_2, s_3) \in \mathcal{R}\)}
            \BinaryInfC{\(\Gamma \vdash (\Pi x:A.B):s_3\)}
        \end{prooftree}
    \end{minipage}
    \caption{Axiom and typing judgements of pure type systems. The application, abstraction and conversion rules (greyed out) are exactly the same as those for the \(\lambda\)-cube. The product rule generalises the \(\lambda\)-cube's \((s_1, s_2)\) rules.}
    \label{fig:pts-typing}
\end{figure}

\section{Classical and modal logics}

\subsection{Parigot's \(\lambda\mu\)-calculus}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(\Gamma, \phi \vdash \phi\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,\phi \vdash \psi\)}
            \LeftLabel{(\(\rightarrow\)I)}
            \UnaryInfC{\(\Gamma \vdash \phi \rightarrow \psi\)}
        \end{prooftree}
    \end{minipage}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash \phi \rightarrow \psi\)}
            \AxiomC{\(\Gamma \vdash \phi\)}
            \LeftLabel{(\(\rightarrow\)E)}
            \BinaryInfC{\(\Gamma \vdash \psi\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,\phi \rightarrow \bot \vdash \bot\)}
            \LeftLabel{(\(\neg\)E)}
            \UnaryInfC{\(\Gamma \vdash \phi\)}
        \end{prooftree}
    \end{minipage}
    \caption{Classical propositional logic, taken from \textcite[129]{sorensen_lectures_2006}. Note that we identify \(\phi \rightarrow \bot\) and \(\neg \phi\), so the premiss for the \(\neg\)E rule could equivalently be written \(\Gamma, \neg \phi \vdash \bot\).}
    \label{fig:classical-prop}
\end{figure}

Until Timothy Griffin discovered that the principle of double negation elimination corresponds to the typing of a control operator, it was commonly believed that the Curry-Howard correspondence was restricted to intuitionistic logic \autocite{griffin_formulae-as-type_1990}. This idea was further developed into the \(\lambda\mu\)-calculus by Parigot \autocite{parigot_-calculus:_1992}. Chapter 6 of \textcite{sorensen_lectures_2006} provides a clear and thorough treatment of the \(\lambda\mu\)-calculus and its correspondence to classical propositional logic, which I will follow in this section.

Firstly, what makes classical propositional logic different from intuitionistic propositional logic? It adds the following principles:

\begin{description}
\item[Law of the excluded middle] \(\phi \vee \neg \phi\). Either \(\phi\) holds, or \(\neg \phi\) holds.
\item[Double negation elimination] \(\neg \neg \phi \rightarrow \phi\). If it is not the case that \(\phi\) does not hold, then \(\phi\) holds.
\item[Peirce's law] \(((\phi \rightarrow \psi) \rightarrow \phi) \rightarrow \phi\).
\item[Reductio ad absurdum] \((\neg \phi \rightarrow \phi) \rightarrow \phi)\). If the assumption that \(\phi\) does not hold implies \(\phi\), then \(\phi\) must hold.
\end{description}

These principles can be derived from the rules given in \cref{fig:classical-prop}. As an example, double negation elimination can be shown as follows:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \neg\neg\phi\)}
    \AxiomC{}
    \UnaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \neg\phi\)}
    \RightLabel{(\(\rightarrow\)E)}
    \BinaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \bot\)}
    \RightLabel{(\(\neg\)E)}
    \UnaryInfC{\(\Gamma, \neg\neg\phi \vdash \phi\)}
    \RightLabel{(\(\rightarrow\)I)}
    \UnaryInfC{\(\Gamma \vdash \neg\neg\phi \rightarrow \phi\)}
\end{prooftree}

The \(\lambda\mu\)-calculus corresponds to classical propositional logic in the same way that \(\lambda\)-calculus does to intuitionistic propositional logic.

\begin{enumerate}
\item \(A\) is the set of \emph{addresses} ranged over by \(a\), and \(V\) the set of variables ranged over by \(x\). Then the set of \(\lambda\mu\)-terms is defined as \[M \Coloneqq x \;|\; M M \;|\; \lambda x\!:\!\sigma.M \;|\; [a] M \;|\; \mu a\!:\!\neg \sigma.M\]
\item An environment \(\Gamma\) is a set of pairs of form \(x:\tau\) \emph{and} \(a:\neg\sigma\).
\item The typing rules are given in \cref{fig:lambda-mu-typing}.
\end{enumerate}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(\Gamma, x:\tau \vdash x:\tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, x:\sigma \vdash M:\tau\)}
            \LeftLabel{(abstraction)}
            \UnaryInfC{\(\Gamma \vdash (\lambda x:\sigma.M) : \sigma \rightarrow \tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash M : \sigma \rightarrow \tau\)}
            \AxiomC{\(\Gamma \vdash N : \sigma\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash (M N) : \tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, a:\neg\sigma \vdash M : \bot\)}
            \LeftLabel{(activate)}
            \UnaryInfC{\(\Gamma \vdash (\mu a:\neg\sigma.M) : \sigma\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, a:\neg\sigma \vdash M : \sigma\)}
            \LeftLabel{(passivate)}
            \UnaryInfC{\(\Gamma, a:\neg\sigma \vdash ([a]M) : \bot\)}
        \end{prooftree}
    \end{minipage}
    \caption{Typing rules of the \(\lambda\mu\), taken from \textcite[133]{sorensen_lectures_2006}. Note that the passivate rule does not have an equivalent in classical propositional logic (\cref{fig:classical-prop}), since the latter does not distinguish between variables and addresses.}
    \label{fig:lambda-mu-typing}
\end{figure}

As an example, Peirce's law \(((p \rightarrow q) \rightarrow p) \rightarrow p\) is inhabited by the \(\lambda\mu\)-term \[\lambda x:(p \rightarrow q) \rightarrow p.\mu a:\neg p.[a](x(\lambda z:p.\mu b:\neg q.[a]z))\]

Proofs of subject reduction, confluence and strong normalisation follow. The chapter concludes by describing an embedding of classical propositional logic in intuitionistic propositional logic (Kolmogorov double negation translation), continuation passing style (CPS) translation and extensions of the logic with more introduction and elimination rules.


\subsection{Intuitionistic modal logic}

The correspondence between intuitionistic modal logic and the \(\lambda\)-calculus was already mentioned in \textcite{curry_elimination_1952}. This connection was re-evaluated much later in a number of papers in the late 1990s and early 200s---\textcite{paiva_modalities_2004} provides a good overview with many references. The paper I will concentrate on in this section is \textcite{benton_computational_1995}, which demonstrates the correspondence between the computational \(\lambda\)-calculus \autocite{moggi_notions_1991} and an intuitionistic modal propositional logic.

The computational \(\lambda\)-calculus is introduced by giving its additional \(\beta\)-reduction rules:

\begin{align*}
\texttt{let}\; x \Leftarrow (\texttt{val}(e)) \;\texttt{in}\; f &\rightarrow_\beta f[e/x] \\
\texttt{let}\; x \Leftarrow e \;\texttt{in}\; (\texttt{val}(x)) &\rightarrow_\beta e \\
\texttt{let}\; x' \Leftarrow (\texttt{let}\; x \Leftarrow e \;\texttt{in}\; f) \;\texttt{in}\; g &\rightarrow_\beta \;\texttt{let}\; x \Leftarrow e \;\texttt{in}\; (\texttt{let}\; x' \Leftarrow f \;\texttt{in}\; g)
\end{align*}

Next the typing rules for the calculus are presented. In addition to the standard axiom as well as introduction and elimination rules for functions, pairs and sums, it contains the axiom \(\Gamma \vdash * : 1\) and the following rules for typing monadic computations in the strong monad \(T\):

\begin{figure}[h]
\begin{minipage}[b]{1\linewidth}
\centering
\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash e : T\,A\)}
    \AxiomC{\(\Gamma,x:A \vdash f : T\,B\)}
    \BinaryInfC{\(\Gamma \vdash \texttt{let}\; x \Leftarrow e \;\texttt{in}\; f : T\,B\)}
\end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.35\linewidth}
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash e : A\)}
    \UnaryInfC{\(\Gamma \vdash \texttt{val}(e) : T\,A\)}
\end{prooftree}
\end{minipage}
\end{minipage}
\end{figure}

The typing derivations of this logic produce a logic the authors call CL-logic by erasing the terms. An explicit correspondence is given between the type constructors and logical connectives.

\begin{table}[h]
\centering
\begin{tabular}{l c c c c c}
\textit{Constructor} & \(1\) & \(\times\) & \(\rightarrow\) & + & \(T\) \\
\textit{Connective} & \(\top\) & \(\wedge\) & \(\supset\) & \(\vee\) & \(\diamond\)
\end{tabular}
\end{table}

Hence \(T\) corresponds to the connective from modal logic \(\diamond\) usually referred to as \enquote{eventually}. The inference rules of CL-logic are given explicitly. The rules dealing with \(\diamond\) are:

\begin{figure}[h]
\begin{minipage}[b]{1\linewidth}
\centering
\begin{minipage}[b]{0.45\linewidth}
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash \diamond A\)}
    \AxiomC{\(\Gamma,A \vdash \diamond B\)}
    \LeftLabel{(\(\diamond\)E)}
    \BinaryInfC{\(\Gamma \vdash \diamond B\)}
\end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.35\linewidth}
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash A\)}
    \LeftLabel{(\(\diamond\)I)}
    \UnaryInfC{\(\Gamma \vdash \diamond A\)}
\end{prooftree}
\end{minipage}
\end{minipage}
\end{figure}

One theorem that can be proved in this logic (the authors call it \enquote{undesirable}) is \[\diamond A \wedge \diamond \neg A \vdash \diamond (A \wedge \neg A)\] Here the left-hand side of \(\vdash\) might be true while the right-hand side \enquote{appears to always be false}. This is not an ideal situation, but consistency is preserved.

The paper then proves some important properties of the calculus, discusses cut elimination and finally gives a categorical model for the computational \(\lambda\)-calculus inspired by Moggi's original representation of \(\diamond\) as a monad.

\section{Conclusions}
lala

\printbibliography

\end{document}
