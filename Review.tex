\RequirePackage[l2tabu, orthodox]{nag}
\documentclass[12pt,toc=bibliography,numbers=noendperiod,
               footnotes=multiple,twoside]{scrartcl}
\usepackage{fixltx2e} % LaTeX patches, \textsubscript
\usepackage{microtype}
\usepackage{cmap} % fix search and cut-and-paste in Acrobat
\usepackage{ifthen}
\usepackage[oldstylenums,largesmallcaps,easyscsl]{kpfonts}
\usepackage[LGR,T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textalpha}
\usepackage[british]{babel}
\usepackage[table,hyperref,dvipsnames]{xcolor}
\usepackage{csquotes}
\usepackage{alltt}
\usepackage{mathtools}
\usepackage{subcaption}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage[all]{xy}
\usepackage{bussproofs}
\usepackage{paralist}
\usepackage{amssymb}
\usepackage[autocite=footnote,citestyle=authoryear-comp,bibstyle=authoryear,
            dashed=false,isbn=false,doi=false,url=false,backend=biber]{biblatex}
\usepackage[bookmarks,hidelinks]{hyperref}
\usepackage[noabbrev,capitalise]{cleveref}

%%% Custom LaTeX preamble
% serif, non-bold headings:
\addtokomafont{disposition}{\rmfamily}
\addtokomafont{descriptionlabel}{\rmfamily}
\addtokomafont{pageheadfoot}{\itshape}
% section numbering up to subsection
\setcounter{secnumdepth}{2}

% hyperlinks
\urlstyle{same} % normal text font (alternatives: tt, rm, sf)
\hypersetup{%
  pdftitle={The Curry-Howard correspondence},
  pdfauthor={Leonhard Markert (lm510), Emmanuel College}
}
\title{The Curry-Howard correspondence}
\author{Leonhard Markert}
\date{}

\addbibresource{Bibliography.bib}
% \pagestyle{headings}

\hyphenation{com-po-nent tran-si-tion-ing}

%%% Body
\begin{document}

\thispagestyle{empty}
\maketitle

\abstract{%
In order to perform automated reasoning, we need to represent our propositions and proofs, define the deduction rules of our theory and automate the process of finding and checking proofs as much as possible. Via the Curry-Howard correspondence, terms and types in typed lambda calculi can be used to represent proofs and propositions, respectively.

In this survey, I review a selection of influential publications on the correspondence between various flavours of the lambda calculus and the propositions and proofs they allow us to represent.%
}

%\tableofcontents
\vspace{10pt}
\makeatletter
\@starttoc{toc}
\makeatother
\newpage

\section{Introduction}

How can type theory help build automated reasoning tools? Fundamentally, to do automated reasoning in a mathematical logic (as opposed to, say, common sense reasoning), three components are required:

\begin{description}
\item[Propositions and proofs] need to be represented within the system. In typed lambda calculi, propositions are represented as types and lambda terms correspond to proofs.
\item[Deduction rules] must be defined. Typing rules play this role in typed lambda calculi. Logics that can be represented in this way include intuitionistic propositional and predicate logics of various kinds (see \cref{sec:power}) as well as classical logics (see \cref{ssc:parigot}).
\item[Automation] makes the proof writer's job easier. There are several approaches to automation in different proof assistants based on the Curry-Howard correspondence. Some use \emph{tactics}, a technique known from proof assistants not based on type theory.\footnote{Coq, a proof assistant based on dependent type theory, uses tactics to automate the search for proofs.} Others allow for interactive refinement of terms/proofs in a development environment.\footnote{Agda, for example, can search for terms (proofs) in the current scope that have a certain type (prove a given proposition).}
\end{description}

One property that all the type theories in this survey have in common is that \emph{type checking} is decidable: given a term and a type, the type checker can always tell whether or not the term has this particular type. This translates to \enquote{proposition checking} via the Curry-Howard correspondence: in the logics corresponding to the type theories discussed here, we can always decide if a given proof actually proves a certain proposition.

An advantage of using typed lambda calculi to represent logic is that by stripping away the types, we can easily extract lambda terms that can be executed, giving us verified software for free---this is usually referred to as the \emph{computational fragment} of the typed lambda calculus.

\subsection{Basic notions and notation}

Familiarity with some notions from logic and type theory will be assumed in later sections. To make this literature survey self-contained, I include a brief introduction here.

\minisec{Logic}

Basic notions in logic include propositions, judgements and contexts. Inference rules and tree-shaped formal proofs are commonly used notations.

\begin{description}
\item[Propositions] are generated from the grammar of the logic. For example, in a logic consisting of the constants \(\top\) and \(\bot\) and the logical connectives \(\wedge\) and \(\rightarrow\), we can construct the propositions \(\top \wedge \bot\), \(\bot \rightarrow \bot\), \(\bot \rightarrow ((\bot \wedge \top) \rightarrow \bot)\) and so on. Usually \(A, B, C\) range over propositions.
\item[Contexts] are sets of propositions. \(\Gamma\) and \(\Delta\) are commonly used to denote contexts.
\item[Judgements] have the form \(\Gamma \vdash A\) where \(\Gamma\) is a context and \(A\) is a proposition. The meaning of such a statement is \enquote{if the propositions in \(\Gamma\) hold, then it can be shown that \(A\) holds}.
\end{description}

As an example of an \emph{inference rule}, take the rule that introduces the logical connective \(\wedge\):

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash A\)}
    \AxiomC{\(\Delta \vdash B\)}
    \LeftLabel{(\(\wedge\)I)}
    \BinaryInfC{\(\Gamma,\Delta \vdash A \wedge B\)}
\end{prooftree}
\end{figure}

The premisses (zero or more) are written above the line and the conclusion (exactly one) below it. \(\Gamma,\Delta\) is common notation for \(\Gamma \cup \Delta\). Rules without premisses are called \enquote{axioms}. The above rule is meant to be read \enquote{assuming that if all propositions in \(\Gamma\) hold then \(A\) holds and also that if all propositions in \(\Delta\) hold then \(B\) holds, we can conclude that if all propositions in \(\Gamma \cup \Delta\) hold then \(A \wedge B\) holds.}

Rules and axioms are combined into tree-shaped proofs like the one in \cref{fig:example-proof}. Two more notational conventions are used here: an assumption-free judgement \(\{\} \vdash A\) is written \(\vdash A\), and usually the curly braces around the set of assumptions is not written, so one will commonly see \(A,B \vdash C\) instead of \(\{A,B\} \vdash C\).

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \wedge A \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)E)}}
    \UnaryInfC{\(B \wedge A \vdash A\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \wedge A \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)E)}}
    \UnaryInfC{\(B \wedge A \vdash B\)}
    \LeftLabel{\scriptsize{(\(\wedge\)I)}}
    \BinaryInfC{\(B \wedge A \vdash A \wedge B\)}
    \LeftLabel{\scriptsize{(\(\rightarrow\)I)}}
    \UnaryInfC{\(\vdash (B \wedge A) \rightarrow (A \wedge B)\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(B \vdash B\)}
    \AxiomC{}
    \LeftLabel{\scriptsize{(axiom)}}
    \UnaryInfC{\(A \vdash A\)}
    \LeftLabel{\scriptsize{(\(\wedge\)I)}}
    \BinaryInfC{\(A,B \vdash B \wedge A\)}
    \LeftLabel{\scriptsize{(\(\rightarrow\)E)}}
    \BinaryInfC{\(A,B \vdash A \wedge B\)}
\end{prooftree}
\caption{A roundabout proof. This example is taken from \textcite{wadler_proofs_2000}.}
\label{fig:example-proof}
\end{figure}


\minisec{Type theory}

The typed lambda calculi that will be discussed in this survey all require the following notions:

\begin{description}
\item[Types] can be thought of as collections of objects. Often types are identified with sets, that is, a typing \(x:A\) (\enquote{\(x\) is of type \(A\)}) is equivalent to \(x \in A\) (\enquote{\(x\) is a member of \(A\)}). Basic types like bool and int together with \(\rightarrow\) (for function types) and \(\wedge\) (for pairs) constitute a grammar of types.
\item[Contexts] are finite partial functions from variables to types, usually written as \(\Gamma = \{x:A,y:B,\dots\}\) where \(\Gamma\) is the name of the context, \(x\) and \(y\) are variables and \(A\) and \(B\) types. In some type theories, order matters---in this case, contexts are ordered lists of (variable, type) tuples.
\item[Judgements] are written \(\Gamma \vdash t:A\) where \(\Gamma\) is a context, \(t\) is a term in the calculus and \(A\) a type. Such a judgement should be read as \enquote{assuming that the variables occurring free in \(t\) have the types that \(\Gamma\) assigns to them, then it can be shown that \(t\) has type \(A\)}.
\end{description}

Typing judgements are the counterpart to inference rules in logic. The rule for introducing pairs is:

\begin{figure}[h]
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash t:A\)}
    \AxiomC{\(\Delta \vdash u:B\)}
    \LeftLabel{(\(\wedge\)I)}
    \BinaryInfC{\(\Gamma,\Delta \vdash (t, u) : A \wedge B\)}
\end{prooftree}
\end{figure}

Premiss, conclusion and axiom have the same meaning as in logic. Typing derivations are built up from typing rules and axioms in the same way that proofs are built from the rules and axioms of logic.

\section{Early work on types and the Curry-Howard correspondence}

According to Thierry Coquand's article on type theory in the Stanford Encyclopedia of Philosophy, \enquote{[the] theory of types was introduced by Russell in order to cope with some contradictions he found in his account of set theory} in 1903 \autocite{coquand_type_2014}. Type theory was initially a tool used by logicians interested in the foundations of mathematics. As type systems grew more expressive, they were used to reason about an increasing number of domains.

\subsection{Howard on the Curry-Howard correspondence}

William Howard coined the slogan \enquote{formulae as types} in a set of notes privately circulated in 1969. They appeared as an essay in a book dedicated to Haskell B. Curry on the occasion of his 80th birthday in 1980 \autocite{howard_formulae-as-types_1980}. By this point, the idea of a correspondence between types and propositions had become widely accepted and research into this suprising connection was well under way. Still, this essay is often cited as the publication that originated what became known as the Curry-Howard correspondence.

As an aside, this correspondence is sometimes called Curry-Howard \emph{isomorphism} instead. In my opinion this is misleading: corresponding logics and typed lambda calculi are not always isomorphic. For example, the logic PRED\(\omega\) corresponds to the typed lambda calculus \(\lambda\)C in Barendregt's Lambda Cube / Logic Cube model (see \cref{ssc:cubes}). But completeness of PRED\(\omega\) with respect to \(\lambda\)C fails, so there are inhabited types in \(\lambda\)C corresponding to unprovable propositions in PRED\(\omega\)---in this instance, no full isomorphism exists \autocite[250]{barendregt_lambda_1992}.

Howard starts by noting that the rule which introduces an implication on the right-hand side in the sequent calculus is similar to \(\lambda\)-abstraction, and \emph{modus ponens} (the elimination rule for implication on the right-hand side) resembles application in the lambda calculus. Rewritten in a notation consistent with the rest of this survey, Howard's modus ponens and application rule look like this:

\begin{figure}[h]
\begin{minipage}[b]{1\linewidth}
\centering
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
    \AxiomC{\(\Delta \vdash A \rightarrow B\)}
    \AxiomC{\(\Gamma \vdash A\)}
    \LeftLabel{\scriptsize{(modus ponens)}}
    \BinaryInfC{\(\Gamma,\Delta \vdash B\)}
\end{prooftree}
\end{minipage}
\begin{minipage}[b]{0.4\linewidth}
\begin{prooftree}
    \AxiomC{\(\vdash f : A \rightarrow B\)}
    \AxiomC{\(\vdash t : A\)}
    \LeftLabel{\scriptsize{(application)}}
    \BinaryInfC{\(\vdash f t : B\)}
\end{prooftree}
\end{minipage}
\end{minipage}
\end{figure}


This simple
% (positive implicational propositional)
logic is then extended to include negation as functions with the empty type as their codomain, conjunction as pairing, and disjunction as what would today be called sum types. These corresponding notions from logic and type theory are listed in \cref{tab:howard}. The second part of the essay is concerned with constructing a set-theoretic interpretation of Heyting arithmetic including existential and universal quantifiers.

\subsection{De Bruijn's Automath project}

In the same book that Howard published his notes in, Nicolaas de Bruijn describes his project \enquote{to develop a system of writing entire mathematical theories in such a precise fashion that verification of the correctness can be carried out by formal operations on the text}, with the goal to use computers for verifying proofs \autocite{de_bruijn_survey_1980}. The implementation of his Automath system is first motivated by describing how automated proof checking would benefit working mathematicians.
% it would increase confidence in the results; it would help in understanding proofs by requiring explicit assumptions; and it would allow for proofs to be processed like any other object in computer memory---one could, for example, find out whether a certain axiom or rule was used in a proof.

Under the heading \enquote{use of typing for reasoning}, de Bruijn gives some intuition for what he calls the \enquote{idea of \emph{propositions as types}} as applied to implication: given propositions \(p\) and \(q\), a proof of the implication \(p \rightarrow q\) can be interpreted as a procedure by which a proof of \(q\) is generated for any \(p\) passed to it.\footnote{This interpretation of intuitionistic logic was originally proposed by Brouwer and Heyting and independently by Kolmogorov and is part of what is commonly referred to as the Brouwer-Heyting-Kolmogorov interpretation.} Later sections of the report discuss the potential benefits of introducing a proposition sort (\enquote{expression of degree 1}), and some ideas about what would nowadays be called \emph{tactics}. Both have been realised in the proof assistant Coq, for example.\footnote{\url{http://coq.inria.fr}}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Logic} & \textit{Type theory} \\
        \midrule
	implication & function space \\
	modus ponens & application \\
	falsity & empty type \\
	negation & functions into the empty type \\
	conjunction & pairs \\
	disjunction & sum types \\
        \bottomrule
    \end{tabular}
    \caption{The Curry-Howard correspondence according to \textcite{howard_formulae-as-types_1980}.}
    \label{tab:howard}
\end{table}


\section{More powerful type systems emerge}

Howard's manuscript was only the beginning: in the decades following the discovery of the correspondence between types theory and logic, researchers found many more concepts that translate both ways between the two frameworks.

As a side note on methodology, most authors whose publications this literature survey discusses published multiple, often many, papers on type theory. It is clear from the amount of cross-referencing and citing in those papers that the leading researchers at the time were often in close contact, criticising each other's work, finding mistakes or opening up new perspectives---\emph{science} was being done.

This makes untangling the development of the subject \emph{a posteriori} difficult. Martin-Löf developed his type theory over the course of multiple publications spanning decades. \enquote{The} Calculus of Constructions does not exist; instead, it is a term used by Coquand and Huet to refer to a family of type theories and conceptual programming languages described in at least four papers.

In this survey, I usually cite and describe the latest of such a series of publications on a particular topic by a particular author or set of authors.

\subsection{Martin-Löf's Intuitionistic Type Theory}

A set of notes from a lecture series given by Per Martin-Löf in 1980 is the canonical reference for \emph{Intuitionistic Type Theory} (often referred to as \enquote{Martin-Löf type theory}), on which most of the following work discussed in this survey is based \autocite{sambin_intuitionistic_1984}.

Before going into type theory proper, Martin-Löf carefully distinguishes \emph{propositions} from \emph{judgements}: propositions are generated from logical operations; holding a proposition to be true is to make a judgement. So when \(A\) is a proposition, then \enquote{\(A\) is true} is a judgement. The premisses and conclusion of a logical inference are judgements. As an example, the rule

\begin{prooftree}
\AxiomC{\(\vdash A\)}
\UnaryInfC{\(\vdash A \vee B\)}
\end{prooftree}

implicitly assumes that \(A\) and \(B\) are propositions, and states that we can infer that \(A \vee B\) holds if \(A\) is true. A formal rule would have to make this explicit:

\begin{prooftree}
\AxiomC{\(A\) prop}
\AxiomC{\(B\) prop}
\AxiomC{\(A\) true}
\TrinaryInfC{\(A \vee B\) true}
\end{prooftree}

\emph{Types} are then introduced using the following four judgements:

\begin{enumerate}
\item \(A\) is a set/type (in the notes this is written as \enquote{\(A\) set}). Sets/types are defined by describing how their canonical elements (\emph{values} in modern lambda calculus terminology) are formed and what equality of elements means in this set/type.
\item \(A\) and \(B\) are equal sets/types (\(A = B\)). \(A\) and \(B\) are equal if \(a : A\) entails \(a : B\) and \(a = b : A\) entails \(a = b : B\) and vice versa.
\item \(a\) is an element of the set/type \(A\) (written \(a \in A\) in the notes; we also use \(a : A\) here). This means that \(a\) is a \enquote{method (or program), which, when executed, yields a canonical element of \(A\) as a result.}
\item \(a\) and \(b\) are equal elements of the set/type \(A\) (written \(a = b \in A\) or \(a = b : A\)). For this to hold, \(a\) and \(b\) must yield equal canonical elements of \(A\) when executed (that is, they must reduce to the same value).
\end{enumerate}

A discussion of \emph{equality} in the context of type theory follows, differentiating between definitional (intensional) equality and propositional (extensional) equality. \emph{Definitional equality} (written \(a \equiv b\)) is the \enquote{equivalence relation generated by abbreviatory definitions, changes of bound variables and the principle of substituting equals for equals.} It is decidable on a meta-level, but \(a \equiv b\) is \emph{not} a proposition within the theory.

\emph{Propositional equality}, on the other hand, resides \emph{within} the theory. \(I(A, a, b)\) is a proposition asserting that \(a\) and \(b\) are equal elements of \(A\).

The remainder of the text contains a systematic account of the correspondence between ways of constructing types on the one hand and logical connectives and quantifiers on the other.\footnote{In the notes, set notation and nomenclature is used for types. I have tried to modernise the notation here for consistency.} Each type-forming symbol (see \cref{tab:martin-loef}) is defined by giving four rules:

\begin{description}
\item[Formation rules] state that this symbol forms a new type from existing types.
\item[Introduction rules] define the meaning of the symbol by giving its \emph{canonical elements}.
\item[Elimination rules] say how functions can be defined on this symbol's types.
\item[Equality rules] \enquote{relate the introduction and elimination rules by showing how a function defined by means of the elimination rule operates on the canonical elements of the [type] which are generated by the introduction rules}.
\end{description}

Considering these from the perspective of logic, formation rules are used to form propositions, introduction and elimination rules allow for Gentzen-style natural deduction, and equality rules correspond to reduction rules---in the parlance of lambda calculus, they would be called \(\beta\)- and \(\eta\)-reduction rules. This relationship between \(\beta\)-reduction and proof normalisation was first discovered by Dag Prawitz \autocite{prawitz_natural_1965}.

\begin{table}[h]
    \centering
    \begin{tabular}{l l l l}
        \toprule
        \textit{Logic} & & \textit{Types} & \\
        \midrule
	universal quantif'n & \((\forall x \in A)\;B(x)\)
		& generalised product & \((\Pi x : A)\;B(x)\) \\
	implication & \(A \rightarrow B\)
		& ---with \(B\) indep't of \(x\) & \((\Pi x : A)\;B\) \\
	existential quantif'n & \((\exists x \in A)\;B(x)\)
		& dependent sum & \((\Sigma x : A)\;B(x)\) \\
	conjunction & \(A \wedge B\)
		& ---with \(B\) indep't of \(x\) & \((\Sigma x : A)\;B\) \\
	disjunction & \(A \vee B\)
		& disjoint union & \(A + B\) \\
	identity & \(A = B\)
		& equality & \(I(A, a, b)\) \\
	
        \bottomrule
    \end{tabular}
    \caption{Symbols defined in Martin-Löf's Intuitionistic Type Theory \parencite{sambin_intuitionistic_1984}.}
    \label{tab:martin-loef}
\end{table}

\subsection{Coquand and Huet's Calculus of Constructions}

Coquand and Huet's \emph{Calculus of Constructions} blends together the theoretical work by Martin-Löf and Girard with the more concrete proposals of de Bruijn \autocite{coquand_calculus_1988}. They first describe the metatheory of the calculus and then provide suggestions concerning how such a calculus could be implemented in a user-friendly way.

In the Calculus of Constructions, \(*\) represents the universe of all types, that is, the type of all types \emph{and} the type of all propositions. \(*\) is not of type~\(*\) to avoid Girard's paradox.\footnote{A judgement like \(* : *\) in a type theory makes it possible to prove any proposition, or equivalently, implies that every type (even \(\bot\)) is inhabited. An early version of Martin-Löf's type theory was shown to suffer from this problem, usually referred to as \emph{Girard's paradox}, and the publication that is usually cited in this context is his doctoral thesis, \textcite{girard_interpretation_1972} (written in French). Thierry Coquand wrote a very readable introduction to the issue for the Stanford Encyclopedia of Philosophy, relating it, amongst others, to Russel's paradox \autocite{coquand_type_2014}. Coq and Agda avoid Girard's paradox via an infinite hierarchy of types---an approach that closely resembles Grothendieck's solution to similar issues in set theory by introducing what are now called \emph{Grothendieck universes} \autocite{artin_orie_1972}.} This differs from the Automath languages, where propositions are of type \textit{prop}, types are of type \textit{type} and both \textit{type} and \textit{prop} have type \(\tau\).

\emph{Contexts} (Martin-Löf's \enquote{hypothetical judgements}) are defined as \enquote{[t]erms formed solely of products over \(*\) [\dots] They are the types of logical propositions and proposition schemas}. The paper refers to other terms as \emph{objects}.

The core calculus, which resembles Martin-Löf's and also draws inspiration from Girard, is then extended by conversion rules of the form \(\Gamma \vdash M \cong N\) meaning that the terms \(M\) and \(N\) denote the same object (where \(\Gamma\) is a context). It formalises \(\beta\)-conversion at the type level.

An interpretation (or semantics) of terms is given: contexts map to products, for example, and variables to projections picking out the appropriate type from the context. It is then shown that the Calculus of Constructions is \emph{consistent} in the sense that \enquote{there exists a proposition which is not inhabited.} This non-inhabited proposition or empty type is usually referred to as \(\bot\) (\enquote{bottom}). What this theorem means is that there is no term in the Calculus of Constructions of type \(\bot\), or equivalently, \emph{false} cannot be derived.

The section concerned with making the Calculus of Constructions user-friendly makes three concrete proposals: allowing local definitions (constants) via a \textit{let} construct;\footnote{\textcite{severi_pure_1994} shows that global and local definitions like \emph{let} preserve normalisation for many Pure Type Systems (see \cref{ssc:pts}), including the Calculus of Constructions.} making type arguments which can be inferred from other arguments implicit; and providing a way to extend the syntax of the language. As an example for the last suggestion, a composition operator is introduced as a syntax extension.


\subsection{Luo's Extended Calculus of Constructions}

The \emph{Extended Calculus of Constructions} (ECC), first presented by Zhaohui Luo in 1989\autocite{luo_ecc_1989}, expanded upon in his PhD thesis\autocite{luo_extended_1990} and used as the basis for his unified type theory in \citetitle{luo_computation_1994}\autocite{luo_computation_1994},

\begin{itemize}
\item combines Martin-Löf's predicative hierarchy of universes with the impredicative \textit{Prop} sort the Calculus of Constructions uses; and
\item adds \(\Sigma\)-types (also called \emph{dependent pairs}) to the Calculus of Constructions to provide an abstraction mechanism.
\end{itemize}

Robert Pollack's LEGO proof development system implements ECC and related type systems \autocite{pollack_theory_1994}.

Propositions \enquote{constitute the \emph{impredicative} level \textit{Prop} of the type hierarchy}, where \enquote{impredicative} can be read as \enquote{potentially self-referential}. \enquote{Every proposition is lifted as a higher-level type}---using the set intuition for types, we have
\begin{align*}
\textit{Prop} \in \textit{Type}_0 \in \textit{Type}_1 \in \;\cdots && \textrm{and} &&
\textit{Prop} \subseteq \textit{Type}_0 \subseteq \textit{Type}_1 \subseteq \;\cdots
\end{align*}

Except for the lowest level \textit{Prop}, the type hierarchy is still \emph{stratified}, which is \enquote{essential for the logical consistency of the calculus}. Coq's type theory, amongst others, is based on this universe where the lowest level is impredicative.

\emph{Dependent pairs} are eliminated in the same way as non-dependent pairs, but the introduction rule is more complicated:
\begin{prooftree}
    \AxiomC{\(\Gamma \vdash M:A\)}
    \AxiomC{\(\Gamma \vdash N:[M/x]B\)}
    \AxiomC{\(\Gamma,x:A \vdash B:\textit{Type}_i\)}
    \LeftLabel{(pair)}
    \TrinaryInfC{\(\Gamma \vdash \textit{pair}_{\Sigma x:A.B} (M,N) : (\Sigma x:A.B)\)}
\end{prooftree}

In words, \(\textit{pair}_{\Sigma x:A.B} (M,N)\) has type \(\Sigma x:A.B\) if

\begin{enumerate}
\item \(M\) has type \(A\);
\item \(N\) has type \([M/x] B\), that is, \(\Gamma \vdash N:B'\) where \(B'\) is obtained by substituting \(M\) for all occurrences of \(x\); and
\item the result of this substitution is itself a well-formed type.
\end{enumerate}

This introduction rule for dependent pairs is more general than that for non-dependent pairs. It collapses to the latter when \(x\) does not occur in \(B\).

After listing the inference rules of ECC, demonstrating its proof-theoretic properties and giving an intuitionistic set-theoretic semantics, Luo discusses the \textit{pragmatics} of ECC: expressing and structuring mathematical theories. The example given in \textcite{luo_ecc_1989} is a theory of rings. A simpler example, which we will use here, is given in \textcite{luo_extended_1990}: \emph{semigroups} (defined as a carrier set closed under an associative binary operation \(\_\cdot\_\)).

A straightforward way of formalising semigroups would be to define a context \(\Gamma_{sg} \triangleq X : \textit{Type}_0, \_\cdot\_ : X \rightarrow X \rightarrow X, p : P_\textrm{assoc}\), where \[P_\textrm{assoc} \triangleq \Pi x,y,z:X.(x \cdot (y \cdot z) = (x \cdot y) \cdot z)\] represents associativity of the binary operation. Luo observes that expressing theories in this way quickly becomes unwieldy.

Instead, he proposes to use \(\Sigma\)-types to represent theories in an abstract manner. An \emph{abstract} theory of semigroups would consists of two parts:\footnote{This presentation of semigroup theory is taken directly from \textcite[100]{luo_extended_1990}.}

\begin{itemize}
\item an (abstract) \emph{signature presentation} \[\textit{Sig}_{sg} \triangleq \Sigma X : \textit{Type}_0. X \rightarrow X \rightarrow X\]
\item an (abstract) \emph{axiom} \(\textit{Ax}_{sg}\) being a predicate over \(\textit{Sig}_{sg}\) which, when given any structure \(s\) of type \(\textit{Sig}_{sg}\), returns its associativity axiom.
\end{itemize}

The signature presentation and the axiom can be packaged together as \[\textit{Mod}_{sg} \triangleq \Sigma s : \textit{Sig}_{sg}. \textit{Ax}_{sg}(s)\] which then represents a complete abstract theory of semigroups. In order to postulate an arbitrary semigroup, one just assumes a context \(\Gamma'_{sg} \triangleq sg : \textit{Mod}_{sg}\). Theorems over any semigroup (abstract theorems) then constitute a predicate \(\textit{Thm}_{sg}\) over \(\textit{Sig}_{sg}\) with the general form \[\textit{Thm}_{sg} \triangleq \lambda s : \textit{Sig}_{sg}. P_1 \wedge P_2 \wedge \dots \wedge P_n\] where \(P_1\) to \(P_n\) are the types corresponding to the theorems that have been proved. Given any concrete semigroup structure, \(\textit{Prf}_{sg}\), a term of type \(\Pi sg : \textit{Mod}_{sg}. \textit{Thm}_{sg}(\pi_1(sg))\), results in the proofs specialised to that particular semigroup structure.

\subsection{Pfenning and Paulin-Mohring's Calculus of Inductive Constructions}

\textcite{pfenning_inductively_1990} extends the Calculus of Constructions with inductively defined types. Interestingly, this extension does not augment its computational capabilities, it only makes the proof language more powerful: primitive recursion realises proof by induction, and primitive recursion is already definable in the computational fragment of the Calculus of Constructions, F\(\omega\).
% XXX blah about predecessor function efficiency and distinguishing 0 from 1

A short introduction to the Calculus of Constructions is given before defining the syntax for inductively defined types. Many examples follow, including a definition of natural numbers (see \cref{fig:nat-inductive-type}) and lists (see \cref{fig:list-inductive-type}).

\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.3\linewidth}
\begin{alltt}
\textbf{indtype} nat : * with
    \textbf{zero} : nat
    \textbf{succ} : nat \(\rightarrow\) nat
end
\end{alltt}
\end{subfigure}
\caption{Natural numbers in the Calculus of Inductive Constructions.}
\label{fig:nat-inductive-type}
\end{figure}

\begin{figure}[h]
\centering
\begin{subfigure}[t]{0.4\linewidth}
\begin{alltt}
\textbf{indtype} list : * \(\rightarrow\) * with
    \textbf{nil}  : [A : *] list A
    \textbf{cons} : [A : *] A \(\rightarrow\) list A \(\rightarrow\) list A
end
\end{alltt}
\end{subfigure}
\caption{Lists in the Calculus of Inductive Constructions.}
\label{fig:list-inductive-type}
\end{figure}

The definition of an inductive type \(\alpha\) can be thought of as a rule for \(\alpha\)-introduction. The corresponding \(\alpha\)-elimination is done via \emph{primitive recursion over \(\alpha\)}. The schema for lists, for example, is given by

\begin{align*}
f A (\textit{nil}\;A) &= h'_1\;A \\
f A (\textit{cons}\;A\;x\;l) &= h'_2\;A\;x\;(\textit{pair}\;l\;(f\;A\;l))
\end{align*}

XXX concluding remarks


\section{Uniform formalisations of the Curry-Howard correspondence}

\subsection{\label{ssc:cubes}Barendregt's Lambda Cube and the Logic Cube}

In the last section of his 191-page chapter \citetitle{barendregt_lambda_1992} in the Handbook of Logic in Computer Science, vol. 2, Henk Barendregt sets out to uniformly describe eight type systems, with the Calculus of Constructions the most powerful \autocite{barendregt_lambda_1992}. The result is the Lambda Cube shown in \cref{fig:lambda-cube}, where edges (\(X \longrightarrow Y\)) represent the inclusion relation \(X \subseteq Y\). The type systems in the Lambda Cube are labelled using Barendregt's own naming scheme. Most of them had already appeared in previous work---see \cref{tab:lambda-cube-type-systems}.

\begin{figure}
\begin{equation*}
\xymatrix@R46pt@C40pt{%
&\lambda\omega\ar@{->}[rr]&&\lambda\textrm{C} \\
\lambda\textrm{2}\ar@{->}[rr]\ar@{->}[ur]&&\lambda\textrm{P2}\ar@{->}[ur] \\
&\lambda\underline{\omega}\ar@{->}[uu]|!{"2,1";"2,3"}\hole\ar@{->}[rr]|!{"4,3";"2,3"}\hole&&\lambda\textrm{P}\underline{\omega}\ar@{->}[uu] \\
\lambda^{\rightarrow}\ar@{->}[uu]\ar@{->}[rr]\ar@{->}[ur]&&\lambda\textrm{P}\ar@{->}[uu]\ar@{->}[ur]
}
\end{equation*}
\caption{The Lambda Cube.}
\label{fig:lambda-cube}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Label} & \textit{Also known as} \\
        \midrule
        \(\lambda^{\rightarrow}\) & Simply typed lambda calculus (Church) \\
        \(\lambda\textrm{2}\) & Polymorphic lambda calculus or \emph{Système F} (Girard) \\
        \(\lambda\omega\) & \emph{Système F\(\omega\)} (Girard) \\
        \(\lambda\textrm{P}\) & \emph{LF} (Harper) and Automath languages (de Bruijn) \\
        \(\lambda\textrm{P2}\) & Studied by Longo and Moggi \\
        \(\lambda\textrm{C} = \lambda\textrm{P}\omega\) & Calculus of Constructions (Coquand and Huet) \\
        \(\lambda\underline{\omega}\) (\enquote{weak} \(\lambda\omega\)) & Related to a system studied by de Lavalette \\
        \(\lambda\textrm{P}\underline{\omega}\) (\enquote{weak} \(\lambda\textrm{P}\omega\)) & --- \\
        \bottomrule
    \end{tabular}
    \caption{Other names for the type systems in the Lambda Cube. Summary based on \textcite[193]{barendregt_lambda_1992}.}
    \label{tab:lambda-cube-type-systems}
\end{table}

A key insight in this uniform description of type systems is the mutual dependence of types and terms: there are

\begin{itemize}
\item terms depending on terms;
\item terms depending on types;
\item types depending on types;
\item types depending on terms (dependent types).
\end{itemize}

Barendregt starts by defining the systems \(\lambda^{\rightarrow}\), \(\lambda\textrm{2}\), \(\lambda\underline{\omega}\) and \(\lambda\textrm{P}\) in the usual way. Then a general treatment of all systems in the Lambda Cube is presented.

\begin{enumerate}
\item The systems of the Lambda Cube have the following abstract syntax: \[\mathcal{T} = V \;|\; C \;|\; \mathcal{T}\mathcal{T} \;|\; \lambda V\!\!:\!\mathcal{T}\!.\mathcal{T} \;|\; \Pi V\!\!:\!\mathcal{T}\!.\mathcal{T}\] where \(V\) and \(C\) stand for variables and constants, respectively. Note that no distinction between type- and term-variables is made.
\item \(\beta\)-reduction is defined using substitution \[(\lambda x:A.B)C \rightarrow_\beta B[x \coloneqq C]\]
\item Contexts are finite ordered sequences of declarations \(x:A\), where \(A \in \mathcal{T}\) and \(x\) a variable. The empty context is written \(<>\).
\item The typing judgements (see \cref{fig:lambda-cube-typing}) define the notion \[\Gamma \vdash A:B\] stating that \(A:B\) can be derived from context \(\Gamma\). Note that \(A \rightarrow B \equiv \Pi x:A.B\) if \(x\) does not appear free in either \(A\) or \(B\) (\(\Pi\)-types are also called \emph{dependent function types}).

There are general rules which apply to all systems and the specific rules called \((s_1, s_2)\) rules. In the following, \(s\), \(s_1\) and \(s_2\) range over the set of \emph{sorts}, \(\mathcal{S} \triangleq \{*, \square\}\).
\item The systems of the Lambda Cube are then defined by instantiating the \((s_1, s_2)\) rules with a subset of \(\{(*,*), (\square, *), (*,\square), (\square, \square)\}\) as in \cref{tab:lambda-cube-s-rules}.

\begin{table}[h]
    \centering
    \begin{tabular}{l l l l l}
        \toprule
        \textit{System} & \multicolumn{4}{l}{\textit{Specific rules}}  \\
        \midrule
        \(\lambda^{\rightarrow}\) & \((*,*)\) & & & \\
        \(\lambda\textrm{2}\) & \((*,*)\) & \((\square, *)\) & & \\
        \(\lambda\textrm{P}\) & \((*,*)\) & & \((*,\square)\) & \\

        \(\lambda\textrm{P2}\) & \((*,*)\) & \((\square, *)\) & \((*,\square)\) & \\

        \(\lambda\underline{\omega}\) & \((*,*)\) & & & \((\square, \square)\) \\

        \(\lambda\omega\) & \((*,*)\) & \((\square, *)\) & & \((\square, \square)\) \\

        \(\lambda\textrm{P}\underline{\omega}\) & \((*,*)\) & & \((*,\square)\) & \((\square, \square)\) \\

        \(\lambda\textrm{P}\omega = \lambda\textrm{C}\) & \((*,*)\) & \((\square, *)\) & \((*,\square)\) & \((\square, \square)\) \\

        \bottomrule
    \end{tabular}
    \caption{Specific rules for the systems of the Lambda Cube. Table taken from \textcite[205]{barendregt_lambda_1992}.}
    \label{tab:lambda-cube-s-rules}
\end{table}
\end{enumerate}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(<>\;\vdash * : \square\)}
        \end{prooftree}
    \end{minipage}
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A : s\)}
            \LeftLabel{(start)}
            \RightLabel{if \(x \notin \Gamma\)}
            \UnaryInfC{\(\Gamma,x:A \vdash x:A\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash C:s\)}
            \LeftLabel{(weakening)}
            \RightLabel{if \(x \notin \Gamma\)}
            \BinaryInfC{\(\Gamma,x:C \vdash A:B\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash F:(\Pi x:A.B)\)}
            \AxiomC{\(\Gamma \vdash a:A\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash F a:B[x \coloneqq a]\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,x:A \vdash b:B\)}
            \AxiomC{\(\Gamma \vdash (\Pi x:A.B):s\)}
            \LeftLabel{(abstraction)}
            \BinaryInfC{\(\Gamma \vdash (\lambda x:A.b):(\Pi x:A.B)\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash B':s\)}
            \AxiomC{\(B =_\beta B'\)}
            \LeftLabel{(conversion)}
            \TrinaryInfC{\(\Gamma \vdash A:B'\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s_1\)}
            \AxiomC{\(\Gamma,x:A \vdash B:s_2\)}
            \LeftLabel{(\((s_1, s_2)\) rule)}
            \BinaryInfC{\(\Gamma \vdash (\Pi x:A.B):s_2\)}
        \end{prooftree}
    \end{minipage}
    \caption{Axiom and typing judgements of the Lambda Cube.}
    \label{fig:lambda-cube-typing}
\end{figure}

% \((\square, *)\) is impredicative

The description of the Lambda Cube is followed by many examples of what kinds of expressions are admissible in its type systems. Next, the \emph{Logic Cube} is introduced (\cref{fig:l-cube}): it contains eight systems of intuitionistic logic, each corresponding to the type system at the same corner in the Lambda Cube. Again, the naming scheme is non-standard so a short description of each logic is provided (\cref{tab:l-cube-names}).

\enquote{Weakly higher-order logics} have variables for higher-order propositions or predicates but no quantification over them. Again, the edges of the cube represent inclusion.

The correspondence between the two cubes is a generalised version of the Curry-Howard interpretation: each formula \(A\) in logic \(L_i\) on the Logic Cube can be interpreted as a type \(\llbracket A \rrbracket\) in the corresponding system \(\lambda_i\) on the Lambda Cube. If \(A\) is provable in \(L_i\) then \(\llbracket A \rrbracket\) is inhabited in \(\lambda_i\) (soundness).\footnote{Barendregt quotes Geuvers' Master thesis from 1988 for this result. Unfortunately I was unable to track it down.} Completeness (inhabitation of \(\llbracket A \rrbracket\) implies \(A\) is provable) holds for propositional logics but not in general for predicate logics. For example, completeness for PRED\(\omega\) (higher-order logic) with respect to \(\lambda\)C (Calculus of Constructions) fails.

\begin{figure}
\begin{equation*}
\xymatrix@R46pt@C16pt{%
&\textrm{PROP}\omega\ar@{->}[rr]&&\textrm{PRED}\omega \\
\textrm{PROP2}\ar@{->}[rr]\ar@{->}[ur]&&\textrm{PRED2}\ar@{->}[ur] \\
&\textrm{PROP}\underline{\omega}\ar@{->}[uu]|!{"2,1";"2,3"}\hole\ar@{->}[rr]|!{"4,3";"2,3"}\hole&&\textrm{PRED}\underline{\omega}\ar@{->}[uu] \\
\textrm{PROP}\ar@{->}[uu]\ar@{->}[rr]\ar@{->}[ur]&&\textrm{PRED}\ar@{->}[uu]\ar@{->}[ur]
}
\end{equation*}
\caption{The Logic Cube.}
\label{fig:l-cube}
\end{figure}

\begin{table}[h]
    \centering
    \begin{tabular}{l l}
        \toprule
        \textit{Label} & \textit{Description} \\
        \midrule
        PROP & Propositional logic \\
        PROP2 & Second-order propositional logic \\
        PROP\(\underline{\omega}\) & Weakly higher-order propositional logic \\
        PROP\(\omega\) & Higher-order propositional logic \\
        PRED & Predicate logic \\
        PRED2 & Second-order predicate logic \\
        PRED\(\underline{\omega}\) & Weakly higher-order predicate logic \\
        PRED\(\omega\) & Higher-order predicate logic \\
        \bottomrule
    \end{tabular}
    \caption{The logics in the Logic Cube. Taken from \textcite[248]{barendregt_lambda_1992}.}
    \label{tab:l-cube-names}
\end{table}


\subsection{\label{ssc:pts}Pure Type Systems}

Berardi and Terlouw independently generalised the framework of the Lambda Cube to what \textcite{barendregt_lambda_1992} calls \emph{Pure Type Systems}. It accomodates all the systems in the Lambda Cube and allows subtle differences between many more type systems to be described in a succinct manner. Pure Type Systems have been implemented in the proof checker LEGO amongst others \autocite{pollack_theory_1994}. The definition given here follows \textcite[213f.]{barendregt_lambda_1992}:

\begin{enumerate}
\item Pure Type Systems have the same abstract syntax as those in the Lambda Cube.
\item The \emph{specification} of a Pure Type System is given by \[S = (\mathcal{S}, \mathcal{A}, \mathcal{R})\] where \(\mathcal{S} \subseteq C\) denotes the \emph{sorts}, \(\mathcal{A}\) is a set of \emph{axioms} of the form \(c:s\) with \(c \in \mathcal{C}\) and \(s \in \mathcal{S}\), and \(\mathcal{R}\) is a set of rules of the form \((s_1, s_2, s_3)\) with \(s_1, s_2, s_3 \in \mathcal{S}\). Rules of the form \((s_1, s_2)\) are an abbreviation for \((s_1, s_2, s_2)\).
\item The set \(V\) of variables is divided into disjoint subsets \(V_s\) for each sort \(s \in \mathcal{S}\) and. \(\prescript{s}{}x, \prescript{s}{}y, \prescript{s}{}z, \dots\) denote members of \(V_s\).
\item Contexts are defined as for the Lambda Cube. The axiom and typing judgements are listed in \cref{fig:pts-typing}, where \(x\) ranges over variables and \(s\) ranges over \(\mathcal{S}\), the set of sorts.
\end{enumerate}

Two type systems also present in the Lambda Cube, \(\lambda^{\rightarrow}\) and \(\lambda\textrm{C}\), are determined as Pure Type Systems by the following specifications:

\begin{align*}
\lambda^{\rightarrow} &\triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square\} \\
        \mathcal{A} &= \{*:\square\} \\
        \mathcal{R} &= \{(*,*),(\square,*)\}
    \end{cases} &
\lambda\textrm{C} &\triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square\} \\
        \mathcal{A} &= \{*:\square\} \\
        \mathcal{R} &= \{(*,*),(\square,*),(*,\square),(\square,\square)\}
    \end{cases}
\end{align*}

An example for a system that cannot be represented in the Lambda Cube is \(\lambda\textrm{U}\), a non-circular system that has been shown to nevertheless be inconsistent by Girard:

\begin{align*}
\lambda\textrm{U} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*,\square,\Delta\} \\
        \mathcal{A} &= \{*:\square,\square:\Delta\} \\
        \mathcal{R} &= \{(*,*),(\square,*),(\square,\square),(\Delta,\square),(\Delta,*)\}
    \end{cases}
\end{align*}

Many lemmas and proofs follow, leading up the the proof of strong normalisation for all systems in the Lambda Cube.

Logics in the Logic Cube can be considered as Pure Type Systems too. One example is propositional logic (PROP), which corresponds to \(\lambda^{\rightarrow}\) in the Lambda Cube. The specification of PROP looks remarkably similar to that of \(\lambda^{\rightarrow}\): the latter can be obtained from the former by removing the superscripts.

\begin{align*}
\lambda\textrm{PROP} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*^p,\square^p\} \\
        \mathcal{A} &= \{*^p:\square^p\} \\
        \mathcal{R} &= \{(*^p,*^p)\}
    \end{cases}
\end{align*}

A more complex example is predicate logic (PRED), determined by the following specification:

\begin{align*}
\lambda\textrm{PRED} \triangleq
    \begin{cases}
        \mathcal{S} &= \{*^s,*^p,*^f,\square^s,\square^p\} \\
        \mathcal{A} &= \{*^s:\square^s,*^p:\square^p\} \\
        \mathcal{R} &= \{(*^p,*^p),(*^s,*^p),(*^s,\square^p),(*^s,*^s,*^f),(*^s,*^f,*^f)\}
    \end{cases}
\end{align*}

The sorts of this Pure Type System are \(*^s\) for sets, \(*^p\) for propositions and~\(*^f\) for first-order functions between the sets in \(*^s\); \(\square^s\) contains \(*^s\) and \(\square^p\) contains \(*^p\). Note that there is no \(\square^f\) since PRED does not allow variables ranging over functions spaces. Its rules can be interpreted as follows:\footnote{For examples of how the \(\lambda\textrm{PRED}\) rules can be used, see \textcite[255]{barendregt_lambda_1992}}

\begin{description}
\item[\((*^p,*^p)\)] allows the formation of implication.
\item[\((*^s,*^p)\)] allows quantification over sets.
\item[\((*^s,\square^p)\)] allows the formation of first-order predicates.
\item[\((*^s,*^s,*^f)\)] allows the formation of a function space between the basic sets.
\item[\((*^s,*^f,*^f)\)] allows the formation of curried functions of several arguments in the basic sets.
\end{description}

\begin{figure}
    \centering
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \RightLabel{if \((c:s) \in \mathcal{A}\)}
            \UnaryInfC{\(<>\;\vdash c:s\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s\)}
            \LeftLabel{(start)}
            \RightLabel{if \(x \equiv \prescript{s}{}x \notin \Gamma\)}
            \UnaryInfC{\(\Gamma,x:A \vdash x:A\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash C:s\)}
            \LeftLabel{(weakening)}
            \RightLabel{if \(x \equiv \prescript{s}{}x \notin \Gamma\)}
            \BinaryInfC{\(\Gamma,x:C \vdash A:B\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash F:(\Pi x:A.B)\)}
            \AxiomC{\(\Gamma \vdash a:A\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash F a:B[x \coloneqq a]\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma,x:A \vdash b:B\)}
            \AxiomC{\(\Gamma \vdash (\Pi x:A.B):s\)}
            \LeftLabel{(abstraction)}
            \BinaryInfC{\(\Gamma \vdash (\lambda x:A.b):(\Pi x:A.B)\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \color{gray}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:B\)}
            \AxiomC{\(\Gamma \vdash B':s\)}
            \AxiomC{\(B =_\beta B'\)}
            \LeftLabel{(conversion)}
            \TrinaryInfC{\(\Gamma \vdash A:B'\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash A:s_1\)}
            \AxiomC{\(\Gamma,x:A \vdash B:s_2\)}
            \LeftLabel{(product)}
            \RightLabel{if \((s_1, s_2, s_3) \in \mathcal{R}\)}
            \BinaryInfC{\(\Gamma \vdash (\Pi x:A.B):s_3\)}
        \end{prooftree}
    \end{minipage}
    \caption{Axiom and typing judgements of Pure Type Systems. The application, abstraction and conversion rules (greyed out) are exactly the same as those for the Lambda Cube. The product rule generalises the Lambda Cube's \((s_1, s_2)\) rules.}
    \label{fig:pts-typing}
\end{figure}

\section{Classical and modal logics}

\subsection{Parigot's \(\lambda\mu\)-calculus}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(\Gamma, \phi \vdash \phi\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,\phi \vdash \psi\)}
            \LeftLabel{(\(\rightarrow\)I)}
            \UnaryInfC{\(\Gamma \vdash \phi \rightarrow \psi\)}
        \end{prooftree}
    \end{minipage}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash \phi \rightarrow \psi\)}
            \AxiomC{\(\Gamma \vdash \phi\)}
            \LeftLabel{(\(\rightarrow\)E)}
            \BinaryInfC{\(\Gamma \vdash \psi\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma,\phi \rightarrow \bot \vdash \bot\)}
            \LeftLabel{(\(\neg\)E)}
            \UnaryInfC{\(\Gamma \vdash \phi\)}
        \end{prooftree}
    \end{minipage}
    \caption{Classical propositional logic, taken from \textcite[129]{sorensen_lectures_2006}. Note that we identify \(\phi \rightarrow \bot\) and \(\neg \phi\), so the premiss for the \(\neg\)E rule could equivalently be written \(\Gamma, \neg \phi \vdash \bot\).}
    \label{fig:classical-prop}
\end{figure}

Until Timothy Griffin discovered that the principle of double negation elimination corresponds to the typing of a control operator, it was commonly believed that the Curry-Howard correspondence was restricted to intuitionistic logic \autocite{griffin_formulae-as-type_1990}. Griffin's idea was further developed into the \(\lambda\mu\)-calculus by Parigot \autocite{parigot_-calculus:_1992}. Chapter 6 of \citetitle{sorensen_lectures_2006} provides a clear and thorough treatment of the \(\lambda\mu\)-calculus and its correspondence to classical propositional logic, which I will follow in this section \autocite{sorensen_lectures_2006}.

Firstly, what makes classical propositional logic different from intuitionistic propositional logic? It adds the following principles (all of which are equivalent in the sense that adding any one of them to an intuitionistic logic makes it possible to derive all other principles):

\begin{description}
\item[Law of the Excluded Middle] \(\phi \vee \neg \phi\). Either \(\phi\) holds, or \(\neg \phi\) holds.
\item[Double Negation Elimination] \(\neg \neg \phi \rightarrow \phi\). If it is not the case that \(\phi\) does not hold, then \(\phi\) holds.
\item[Peirce's Law] \(((\phi \rightarrow \psi) \rightarrow \phi) \rightarrow \phi\).
\item[Reductio Ad Absurdum] \((\neg \phi \rightarrow \phi) \rightarrow \phi\). If the assumption that \(\phi\) does not hold implies \(\phi\), then \(\phi\) must hold.
\end{description}

These principles can be derived from the rules given in \cref{fig:classical-prop}. As an example, double negation elimination can be shown as follows:

\begin{prooftree}
    \AxiomC{}
    \UnaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \neg\neg\phi\)}
    \AxiomC{}
    \UnaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \neg\phi\)}
    \LeftLabel{(\(\rightarrow\)E)}
    \BinaryInfC{\(\Gamma, \neg\neg\phi, \neg\phi \vdash \bot\)}
    \LeftLabel{(\(\neg\)E)}
    \UnaryInfC{\(\Gamma, \neg\neg\phi \vdash \phi\)}
    \LeftLabel{(\(\rightarrow\)I)}
    \UnaryInfC{\(\Gamma \vdash \neg\neg\phi \rightarrow \phi\)}
\end{prooftree}

The typing axiom and rules of the \(\lambda\mu\)-calculus correspond to classical propositional logic in the same way that those of the lambda calculus relate to intuitionistic propositional logic.

\begin{enumerate}
\item \(A\) is the set of \emph{addresses} ranged over by \(a\), and \(V\) the set of variables ranged over by \(x\). Types are ranged over by \(\sigma\) and \(\tau\). The set of \(\lambda\mu\)-terms is defined as \[M \Coloneqq x \;|\; M M \;|\; \lambda x\!:\!\sigma.M \;|\; [a] M \;|\; \mu a\!:\!\neg \sigma.M\]
\item An environment \(\Gamma\) is a set of declarations of the form \(x:\tau\) or \(a:\neg\sigma\).
\item The typing rules are given in \cref{fig:lambda-mu-typing}.
\end{enumerate}

\begin{figure}
    \centering
    \begin{minipage}[b]{.3\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \LeftLabel{(axiom)}
            \UnaryInfC{\(\Gamma, x:\tau \vdash x:\tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, x:\sigma \vdash M:\tau\)}
            \LeftLabel{(abstraction)}
            \UnaryInfC{\(\Gamma \vdash (\lambda x:\sigma.M) : \sigma \rightarrow \tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.4\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma \vdash M : \sigma \rightarrow \tau\)}
            \AxiomC{\(\Gamma \vdash N : \sigma\)}
            \LeftLabel{(application)}
            \BinaryInfC{\(\Gamma \vdash (M N) : \tau\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, a:\neg\sigma \vdash M : \bot\)}
            \LeftLabel{(activate)}
            \UnaryInfC{\(\Gamma \vdash (\mu a:\neg\sigma.M) : \sigma\)}
        \end{prooftree}
    \end{minipage}
    \\
    \vspace{10pt}
    \begin{minipage}[b]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{\(\Gamma, a:\neg\sigma \vdash M : \sigma\)}
            \LeftLabel{(passivate)}
            \UnaryInfC{\(\Gamma, a:\neg\sigma \vdash ([a]M) : \bot\)}
        \end{prooftree}
    \end{minipage}
    \caption{Typing rules of the \(\lambda\mu\)-calculus, taken from \textcite[133]{sorensen_lectures_2006}. Note that the passivate rule does not have an equivalent in classical propositional logic (\cref{fig:classical-prop}), since the latter does not distinguish between variables and addresses.}
    \label{fig:lambda-mu-typing}
\end{figure}

As an example, Peirce's law \(((p \rightarrow q) \rightarrow p) \rightarrow p\) is inhabited by the term \[\lambda x:(p \rightarrow q) \rightarrow p.\mu a:\neg p.[a](x(\lambda z:p.\mu b:\neg q.[a]z))\]

Proofs of subject reduction, confluence and strong normalisation follow. The chapter concludes by describing an embedding of classical propositional logic in intuitionistic propositional logic (Kolmogorov double negation translation), continuation passing style (CPS) translation and extensions of the logic with more introduction and elimination rules.


\section{Conclusions}

XXX

\printbibliography

\end{document}
